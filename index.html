<!-- 
WMATA Bus Schedule Viewer

This application uses data provided by the WMATA API. Special thanks to WMATA for graciously providing free web API
access.

Copyright (c) 2024 Cyrus Nourbakhsh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Author
Contact: Cyrus Nourbakhsh
Email: osistlk@gmail.com
 -->


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WMATA Bus Data</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 10px;
        }

        main {
            max-width: 600px;
            margin: 20px auto;
            padding: 15px;
            background: #fff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, .1);
        }

        footer {
            max-width: 600px;
            margin: 20px auto;
            padding: 15px;
            background: #fff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, .1);
        }

        h1 {
            font-size: 1.6em;
            text-align: center;
            color: #333;
        }

        .stop {
            background-color: #fff;
            border-left: 5px solid #0078d7;
            margin-bottom: 20px;
            padding: 10px 15px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, .1);
        }

        .stop h2 {
            margin-top: 0;
            color: #0078d7;
            font-size: 1.4em;
        }

        .stop p {
            font-size: 1em;
            margin: 5px 0;
        }

        @media (max-width: 600px) {
            main {
                width: 95%;
                margin: 10px auto;
                padding: 10px;
            }

            .stop {
                padding: 10px 10px;
            }
        }
    </style>
    <!-- good ol jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>

<body>
    <main>
        <div id="route-alerts"></div>
        <h1>2A Bus Stop Data</h1>
        <div id="stops-container"></div>
    </main>

    <script>
        $(document).ready(async function () {
            // Take my key if you want but what are you gonna do with it? Look up the bus 1000+ times an hour?
            const apiKey = '86d6d68074cd4c9ab603ebef0d0a9b33'; // Replace with your WMATA API key
            const busRoute = '2A';
            const stopIDs = ['6000559', '6000567', '6000822', '6000901'];
            const alertsUrl = `https://api.wmata.com/Incidents.svc/json/BusIncidents?Route=${busRoute}`;
            const predictionsUrl = 'https://api.wmata.com/NextBusService.svc/json/jPredictions';
            const scheduleUrl = 'https://api.wmata.com/Bus.svc/json/jStopSchedule';
            const stopsContainer = $('#stops-container');
            const routeAlertsContainer = $('#route-alerts');

            // Function to update data
            async function updateData() {
                stopsContainer.empty();
                routeAlertsContainer.empty();

                async function fetchRouteAlerts() {
                    try {
                        const response = await $.ajax({
                            url: alertsUrl,
                            headers: { 'api_key': apiKey }
                        });

                        if (response.BusIncidents && response.BusIncidents.length > 0) {
                            return response.BusIncidents;
                        } else {
                            return null;
                        }
                    } catch (error) {
                        console.error('Error fetching route alerts:', error);
                        return null;
                    }
                }

                const alerts = await fetchRouteAlerts();
                if (alerts) {
                    const alertsContainer = $('#route-alerts');
                    alertsContainer.append('<h2>Route Alerts</h2>');
                    alerts.forEach(alert => {
                        alertsContainer.append(`<p>${alert.Description}</p>`);
                    });
                }

                async function fetchStopData(stopID) {
                    const predictionsRequest = $.ajax({
                        url: `${predictionsUrl}?StopID=${stopID}&RouteID=${busRoute}`,
                        headers: { 'api_key': apiKey }
                    });

                    const scheduleRequest = $.ajax({
                        url: `${scheduleUrl}?StopID=${stopID}&RouteID=${busRoute}`,
                        headers: { 'api_key': apiKey }
                    });

                    try {
                        const [predictionsResponse, scheduleResponse] = await Promise.all([predictionsRequest, scheduleRequest]);

                        // Manually filter 2A buses because the API does not respect filter param
                        predictionsResponse.Predictions = predictionsResponse.Predictions.filter(prediction => prediction.RouteID === busRoute);
                        scheduleResponse.ScheduleArrivals = scheduleResponse.ScheduleArrivals.filter(scheduled => scheduled.RouteID === busRoute);

                        // Filter scheduled arrivals within a 60-minute window
                        filteredScheduleArrivals = scheduleResponse.ScheduleArrivals.filter(scheduled => {
                            const scheduledTime = new Date(scheduled.ScheduleTime) // Convert to Date object
                            let now = new Date();
                            now.setHours(now.getHours() - 1);
                            let future = new Date();
                            future.setHours(future.getHours() + 1);
                            return scheduledTime >= now && scheduledTime <= future;
                        });

                        return {
                            stopID,
                            stopName: predictionsResponse.StopName,
                            predictions: predictionsResponse.Predictions,
                            scheduleArrivals: filteredScheduleArrivals
                        };
                    } catch (error) {
                        return {
                            stopID,
                            error: true,
                            errorMessage: error.statusText
                        };
                    }
                }

                let stopsData = await Promise.all(stopIDs.map(fetchStopData));

                // Sort stops by stop ID
                stopsData.sort((a, b) => a.stopID.localeCompare(b.stopID));

                // Display each stop's data
                stopsData.forEach(stopData => {
                    const stopDiv = $('<div>').addClass('stop');
                    stopDiv.append(`<h2>Stop ID: ${stopData.stopID}</h2>`);
                    stopDiv.append(`<p>Stop Name: ${stopData.stopName}</p>`);


                    if (stopData.error) {
                        stopDiv.append(`<p>Error fetching data for stop ID ${stopData.stopID}: ${stopData.errorMessage}</p>`);
                    } else {
                        if (stopData.predictions.length > 0) {
                            stopData.predictions.forEach(prediction => {
                                stopDiv.append(`<p><b>Vehicle ${prediction.VehicleID} arriving in ${prediction.Minutes} minutes (Direction: ${prediction.DirectionText})</b></p>`);
                            });
                        } else {
                            stopDiv.append(`<p><b>No real-time predictions available.</b></p>`);
                        }

                        if (stopData.scheduleArrivals.length > 0) {
                            stopData.scheduleArrivals.forEach(arrival => {
                                const arrivalTime = new Date(arrival.ScheduleTime);
                                stopDiv.append(`<p>Scheduled arrival at ${arrivalTime.toLocaleTimeString('en-US')}</p>`);
                            });
                        } else {
                            stopDiv.append(`<p>No scheduled arrivals within the next 60 minutes.</p>`);
                        }
                    }

                    stopsContainer.append(stopDiv);
                });
            }
            // Initial data load
            updateData();
            // Refresh data every 30 seconds
            setInterval(updateData, 30000);
        });
    </script>
    <footer>
        <p>Disclaimer: This application is provided as-is, and the data is sourced from the WMATA API. While efforts are
            made to keep the information accurate and up-to-date, Cyrus Nourbakhsh does not
            guarantee the accuracy, reliability, or timeliness of the data. This application is not officially
            affiliated with WMATA.</p>
        <p>Copyright (c) 2024 Cyrus Nourbakhsh</p>
    </footer>
</body>

</html>